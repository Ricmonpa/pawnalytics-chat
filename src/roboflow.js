// Roboflow API Integration Module
// Maneja las llamadas a las APIs de Roboflow para detecci√≥n por visi√≥n computarizada

// Configuraci√≥n de Roboflow desde variables de entorno
const ROBOFLOW_CONFIG = {
  apiKey: import.meta.env.VITE_ROBOFLOW_API_KEY,
  projects: {
    obesity: {
      id: import.meta.env.VITE_ROBOFLOW_OBESITY_PROJECT,
      version: import.meta.env.VITE_ROBOFLOW_OBESITY_VERSION
    },
    cataracts: {
      id: import.meta.env.VITE_ROBOFLOW_CATARACTS_PROJECT,
      version: import.meta.env.VITE_ROBOFLOW_CATARACTS_VERSION
    },
    dysplasia: {
      id: import.meta.env.VITE_ROBOFLOW_DYSPLASIA_PROJECT,
      version: import.meta.env.VITE_ROBOFLOW_DYSPLASIA_VERSION
    }
  }
};

// Funci√≥n para verificar si la configuraci√≥n est√° disponible
const isRoboflowConfigured = () => {
  return ROBOFLOW_CONFIG.apiKey && 
         ROBOFLOW_CONFIG.apiKey !== 'your-roboflow-api-key-here' &&
         ROBOFLOW_CONFIG.projects.obesity.id &&
         ROBOFLOW_CONFIG.projects.cataracts.id &&
         ROBOFLOW_CONFIG.projects.dysplasia.id;
};

// Funci√≥n para convertir imagen a base64 si no lo est√°
const ensureBase64 = (imageData) => {
  if (typeof imageData === 'string') {
    // Si ya es base64, verificar si tiene el prefijo data:image
    if (imageData.startsWith('data:image')) {
      // Extraer solo la parte base64
      return imageData.split(',')[1];
    }
    // Si es base64 sin prefijo, devolver tal como est√°
    return imageData;
  }
  // Si no es string, asumir que es un File o Blob
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(imageData);
  });
};

// Funci√≥n para hacer llamada a la API de Roboflow
const callRoboflowAPI = async (imageData, projectType) => {
  try {
    // Verificar configuraci√≥n
    if (!isRoboflowConfigured()) {
      throw new Error('Roboflow no est√° configurado correctamente');
    }

    const project = ROBOFLOW_CONFIG.projects[projectType];
    if (!project) {
      throw new Error(`Tipo de proyecto no v√°lido: ${projectType}`);
    }

    // Asegurar que la imagen est√© en base64
    const base64Image = await ensureBase64(imageData);

    // Construir URL de la API
    const apiUrl = `https://detect.roboflow.com/${project.id}/${project.version}`;
    
    // Par√°metros de la API
    const params = new URLSearchParams({
      api_key: ROBOFLOW_CONFIG.apiKey,
      confidence: 40, // Umbral de confianza
      overlap: 30, // Solapamiento permitido
      format: 'json' // Formato de respuesta
    });

    // Realizar la llamada a la API
    const response = await fetch(`${apiUrl}?${params}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: `data:image/jpeg;base64,${base64Image}`
    });

    if (!response.ok) {
      throw new Error(`Error en la API de Roboflow: ${response.status} ${response.statusText}`);
    }

    const result = await response.json();
    return result;

  } catch (error) {
    console.error(`Error en llamada a Roboflow API (${projectType}):`, error);
    throw error;
  }
};

// Funci√≥n para analizar obesidad usando Roboflow
export const analyzeObesityWithRoboflow = async (imageData) => {
  try {
    console.log('üîç Iniciando an√°lisis de obesidad con Roboflow...');
    
    const result = await callRoboflowAPI(imageData, 'obesity');
    
    console.log('üîç Resultado de Roboflow (obesidad):', result);
    
    // Procesar resultados de obesidad
    const analysis = {
      detected: result.predictions && result.predictions.length > 0,
      confidence: result.predictions ? Math.max(...result.predictions.map(p => p.confidence)) : 0,
      predictions: result.predictions || [],
      image: result.image || null
    };

    return {
      success: true,
      analysis,
      rawResult: result
    };

  } catch (error) {
    console.error('Error en an√°lisis de obesidad con Roboflow:', error);
    return {
      success: false,
      error: error.message,
      analysis: null
    };
  }
};

// Funci√≥n para analizar cataratas usando Roboflow
export const analyzeCataractsWithRoboflow = async (imageData) => {
  try {
    console.log('üîç Iniciando an√°lisis de cataratas con Roboflow...');
    
    const result = await callRoboflowAPI(imageData, 'cataracts');
    
    console.log('üîç Resultado de Roboflow (cataratas):', result);
    
    // Procesar resultados de cataratas
    const analysis = {
      detected: result.predictions && result.predictions.length > 0,
      confidence: result.predictions ? Math.max(...result.predictions.map(p => p.confidence)) : 0,
      predictions: result.predictions || [],
      image: result.image || null
    };

    return {
      success: true,
      analysis,
      rawResult: result
    };

  } catch (error) {
    console.error('Error en an√°lisis de cataratas con Roboflow:', error);
    return {
      success: false,
      error: error.message,
      analysis: null
    };
  }
};

// Funci√≥n para analizar displasia usando Roboflow
export const analyzeDysplasiaWithRoboflow = async (imageData) => {
  try {
    console.log('üîç Iniciando an√°lisis de displasia con Roboflow...');
    
    const result = await callRoboflowAPI(imageData, 'dysplasia');
    
    console.log('üîç Resultado de Roboflow (displasia):', result);
    
    // Procesar resultados de displasia
    const analysis = {
      detected: result.predictions && result.predictions.length > 0,
      confidence: result.predictions ? Math.max(...result.predictions.map(p => p.confidence)) : 0,
      predictions: result.predictions || [],
      image: result.image || null
    };

    return {
      success: true,
      analysis,
      rawResult: result
    };

  } catch (error) {
    console.error('Error en an√°lisis de displasia con Roboflow:', error);
    return {
      success: false,
      error: error.message,
      analysis: null
    };
  }
};

// Funci√≥n para determinar autom√°ticamente qu√© an√°lisis realizar
export const autoAnalyzeWithRoboflow = async (imageData, context = '') => {
  try {
    console.log('üîç Iniciando an√°lisis autom√°tico con Roboflow...');
    console.log('üîç Contexto:', context);
    
    const lowerContext = context.toLowerCase();
    
    // Determinar qu√© an√°lisis realizar basado en el contexto
    let analysisType = null;
    
    if (lowerContext.includes('obesidad') || lowerContext.includes('peso') || 
        lowerContext.includes('obesity') || lowerContext.includes('weight') ||
        lowerContext.includes('gordo') || lowerContext.includes('fat')) {
      analysisType = 'obesity';
    } else if (lowerContext.includes('catarata') || lowerContext.includes('ojo') ||
               lowerContext.includes('cataract') || lowerContext.includes('eye') ||
               lowerContext.includes('visi√≥n') || lowerContext.includes('vision')) {
      analysisType = 'cataracts';
    } else if (lowerContext.includes('displasia') || lowerContext.includes('cadera') ||
               lowerContext.includes('dysplasia') || lowerContext.includes('hip') ||
               lowerContext.includes('cojera') || lowerContext.includes('limping')) {
      analysisType = 'dysplasia';
    }
    
    // Si no se determin√≥ un tipo espec√≠fico, intentar todos
    if (!analysisType) {
      console.log('üîç No se determin√≥ tipo espec√≠fico, intentando an√°lisis de obesidad por defecto');
      analysisType = 'obesity';
    }
    
    let result;
    switch (analysisType) {
      case 'obesity':
        result = await analyzeObesityWithRoboflow(imageData);
        break;
      case 'cataracts':
        result = await analyzeCataractsWithRoboflow(imageData);
        break;
      case 'dysplasia':
        result = await analyzeDysplasiaWithRoboflow(imageData);
        break;
      default:
        result = await analyzeObesityWithRoboflow(imageData);
    }
    
    return {
      ...result,
      analysisType,
      autoDetected: true
    };

  } catch (error) {
    console.error('Error en an√°lisis autom√°tico con Roboflow:', error);
    return {
      success: false,
      error: error.message,
      analysisType: null,
      autoDetected: false
    };
  }
};

// Funci√≥n para formatear resultados de Roboflow en espa√±ol
export const formatRoboflowResults = (result, analysisType, language = 'es') => {
  if (!result.success) {
    return language === 'en' 
      ? '‚ùå **Roboflow Analysis Error**\n\nUnable to complete the computer vision analysis. Please try again or consult your veterinarian.'
      : '‚ùå **Error en An√°lisis de Roboflow**\n\nNo se pudo completar el an√°lisis de visi√≥n computarizada. Por favor, intenta de nuevo o consulta con tu veterinario.';
  }

  const { analysis } = result;
  
  if (!analysis.detected) {
    return language === 'en'
      ? `‚úÖ **Roboflow Analysis Completed**\n\nNo ${analysisType} conditions were detected in the image.\n\nConfidence: ${(analysis.confidence * 100).toFixed(1)}%\n\nüí° **Note:** This analysis is preliminary. Continue with regular veterinary checkups.`
      : `‚úÖ **An√°lisis de Roboflow Completado**\n\nNo se detectaron condiciones de ${analysisType} en la imagen.\n\nConfianza: ${(analysis.confidence * 100).toFixed(1)}%\n\nüí° **Nota:** Este an√°lisis es preliminar. Contin√∫a con revisiones veterinarias regulares.`;
  }

  // Formatear predicciones detectadas
  const predictions = analysis.predictions.map(pred => {
    const confidence = (pred.confidence * 100).toFixed(1);
    return `‚Ä¢ **${pred.class}**: ${confidence}% de confianza`;
  }).join('\n');

  return language === 'en'
    ? `üîç **Roboflow Analysis Results**\n\n**Analysis Type:** ${analysisType.toUpperCase()}\n**Overall Confidence:** ${(analysis.confidence * 100).toFixed(1)}%\n\n**Detected Conditions:**\n${predictions}\n\n‚ö†Ô∏è **Recommendations:**\n‚Ä¢ Veterinary consultation recommended\n‚Ä¢ Monitor for changes\n‚Ä¢ Follow professional guidance\n\nüí° **Note:** This is a preliminary analysis. Only a veterinarian can provide a definitive diagnosis.`
    : `üîç **Resultados del An√°lisis de Roboflow**\n\n**Tipo de An√°lisis:** ${analysisType.toUpperCase()}\n**Confianza General:** ${(analysis.confidence * 100).toFixed(1)}%\n\n**Condiciones Detectadas:**\n${predictions}\n\n‚ö†Ô∏è **Recomendaciones:**\n‚Ä¢ Consulta veterinaria recomendada\n‚Ä¢ Monitoreo de cambios\n‚Ä¢ Seguir orientaci√≥n profesional\n\nüí° **Nota:** Este es un an√°lisis preliminar. Solo un veterinario puede proporcionar un diagn√≥stico definitivo.`;
};

// Funci√≥n para verificar el estado de la configuraci√≥n
export const getRoboflowStatus = () => {
  return {
    configured: isRoboflowConfigured(),
    projects: {
      obesity: !!ROBOFLOW_CONFIG.projects.obesity.id,
      cataracts: !!ROBOFLOW_CONFIG.projects.cataracts.id,
      dysplasia: !!ROBOFLOW_CONFIG.projects.dysplasia.id
    }
  };
};

// Exportar configuraci√≥n para debugging (sin la API key)
export const getRoboflowConfig = () => {
  return {
    configured: isRoboflowConfigured(),
    projects: ROBOFLOW_CONFIG.projects,
    hasApiKey: !!ROBOFLOW_CONFIG.apiKey && ROBOFLOW_CONFIG.apiKey !== 'your-roboflow-api-key-here'
  };
};

export default {
  analyzeObesityWithRoboflow,
  analyzeCataractsWithRoboflow,
  analyzeDysplasiaWithRoboflow,
  autoAnalyzeWithRoboflow,
  formatRoboflowResults,
  getRoboflowStatus,
  getRoboflowConfig
}; 